# PokemonApp

Ссылка с apk файлом: https://drive.google.com/file/d/1H64NFog4ZIHDsegWabHAItC-1i8Y5HAJ/view

#### Требования к технологиям:
* язык Java или Kotlin
* система сборки Gradle
* интерфейс простой, но аккуратный
* для списков использовать RecyclerView
* минимальная версия Android — любая
* можно использовать библиотеки

#### Суть задачи:
Используя серверное API https://pokeapi.co/, написать Android-приложение в котором:
1. Отобразить список из 30 покемонов на главном экране. Каждый элемент списка должен
как минимум содержать название покемона и его изображение.

2. Добавить возможность просмотра детальной информации о покемоне. Для этого сделать
отдельный экран, на который можно попасть, кликнув по любому элементу списка
покемонов. Детальная информация как минимум должна включать следующие поля: рост
(height), вес (weight), род покемона (type, например: птица, насекомое, ядовитый и т. д.),
информация (stats; включить поля attack, defense, hp).

3. Реализовать постраничную подгрузку элементов списка покемонов следующим образом:
во время скроллинга списка при достижении его конца загрузить следующие 30 элементов
и отобразить в списке.

4. Добавить кнопку на главный экран, при нажатии на которую список покемонов будет заново
проинициализирован с началом на произвольном элементе из базы данных покемонов
на сервере. При этом минимальная длина списка всегда должна быть не меньше 30 элементов.

5. Добавить 3 флажка (CheckBox) на главный экран с надписями attack, defense и hp, реализующих
следующее поведение. При активации флажка attack/defense/hp, осуществить поиск покемона
с самым большим показателем в поле attack/defense/hp среди покемонов из текущего
списка. Переместить найденного покемона в начало списка, проскроллить список вверх, если
это необходимо, визуально выделить данный элемент списка. Если выделены два или три
флажка, осуществить поиск покемона, у которого выбранные показатели больше остальных.
Если невозможно однозначно определить самого сильного покемона по выбранным
показателям, поступить на своё усмотрение.

#### Дополнительные задания:
1. Дополнение к пункту 5: выполнить поиск самого сильного покемона по одному выбранному
показателю наиболее оптимальным способом.
2. Вместо поиска (пункт 5) можно сделать сортировку текущего списка покемонов по выбранным
показателям.
3. Реализовать кеширование уже загруженных с сервера элементов списка таким образом,
чтобы в случае отсутствия интернет-соединения при открытии приложения была доступна
вся его функциональность.

#### Что сделано:

Overview:
Приложение построено по принципу Clean Architecture в связке с MVVM. Подход Single Activity Multiple Fragments, реализовано через Jetpack Navigation с Safe Args. Для работы с сетью используется Retrofit в связке с RxJava и Kotlin Flow. Для кэширования (persistence) используется Room. Для di используется Dagger Hilt.


Главный экран (PokemonList):
На экране находится RecyclerView, использующий адаптер из Jetpack Paging 3. Элементы в RecyclerView размещаются в две колонки. Айтемы в RecyclerView имеют несколько состояний: Preview, Loaded, Best. **Здесь соблюдены пункты 1 и 3 задания**

* В состоянии Preview покемон подгружен из листа вызовом запроса формата https://pokeapi.co/api/v2/pokemon/ Другими словами, в таком состоянии для айтема скачаны id, имя и image URL, у него нет параметров stats, то есть его нельзя сравнивать с другими по атаке, защите и здоровью. В списке такой покемон имеет красный крест для индикации статуса.

* В состоянии Loaded покемон уже подгружен в репозиторий и его можно сравнивать с другими по stats. Такой покемон имеет для индикации зеленую галочку. Чтобы перейти из состояния Preview в Loaded, нужно либо дождаться, пока приложение подгрузит айтем самостоятельно (там очередь), либо самостоятельно нажать на айтем, после чего вернуться назад на главный экран. Айтем окажется подгруженным.

* Loaded и Preview я сделал для того, чтобы у пользователей была возможность свайпать список очень быстро и не ждать загрузки. Решение, где нужно дожидаться полной загрузки всей информации о покемонах (30 больших api вызовов для одной страницы) я посчитал не таким удачным как выбранное мной.

* Подгрузка происходит в репозитории. Для оповещения RecyclerView о подгрузке детальной информации используется PublishSubject из RxJava. Для подгрузки превью в RecyclerView используется StateFlow, образованный из источника пагинации (смотрите в классе PokemonListViewModel).

* В состоянии Best айтем приобретает желтую рамку, которая означает, что данный покемон лучший по выбранным параметрам. Выбор организован таким образом, что лучших покемонов может быть от 1 до n. Фактически под капотом происходит сортировка кастомным компаратором по выбранным параметрам и теоретически возможна ситуация, когда все покемоны окажутся лучшими, этот момент учтен.

Floating Button справа внизу нужна для перемешивания айтемов (переход на случайную страницу с сервера), это из пункта 4 задания. К слову, получение числа возможных страниц для рандома не захардкожено, а основано на основе числа всех покемонов (получено с api при первом вызове при открытии приложения), которое разделили на размер страницы (30).

Наверху находится 3 чекбокса. Всё **в соответствии с пунктом 5**. Как я указал выше, используется компаратор:
```
private class PokemonComparator(
        private val byAttack: Boolean,
        private val byDefence: Boolean,
        private val byHp: Boolean
    ): Comparator<Pokemon> {
        override fun compare(p0: Pokemon?, p1: Pokemon?): Int {

            if(p0 == null || p1 == null) {
                return 0;
            }

            val p0Sum = p0.getStatsSum(byAttack, byDefence, byHp)
            val p1Sum = p1.getStatsSum(byAttack, byDefence, byHp)

            return p1Sum.compareTo(p0Sum)
        }
    }
```
Где **getStatsSum** - extension метод для доменной модели Pokemon, имеет следующий вид:
```
fun Pokemon.getStatsSum(
    byAttack: Boolean,
    byDefence: Boolean,
    byHp: Boolean
): Int {
    var result = 0

    if (byAttack) {
        result += this.stats?.attack ?: 0
    }

    if (byDefence) {
        result += this.stats?.defence ?: 0
    }

    if (byHp) {
        result += this.stats?.hp ?: 0
    }

    return result
}
```

При изменении значения любого чекбокса вызывается метод для пересчитывания листа с покемонами c использованием компаратора по параметрам чекбоксов, для которых isChecked == true. Чтобы сортировать, например, по 6 параметрам, надо просто добавить по 3 строчки в каждый метод - комбинаторной катастрофы с кучей if не будет. **Таким образом, пункты 1 и 2 дополнительного задания считаю выполненными**

Экран с деталями покемона (PokemonDetailsFragment):
Здесь все просто. При нажатии на айтем из списка происходит навигация на фрагмент с деталями по id, с которым ассоциирован айтем. При создании фрагмента через Safe Args берется id данного покемона, после чего фрагмент через свою ViewModel делает запрос в репозиторий на получение деталей покемона по этому id. Если покемон уже был подгружен, то отображение произойдет мгновенно, так как он закэширован в репозитории, иначе придется подождать доли секунды. Из интересного можно отметить, что параметры type покемона перечисляются через Chips. Также добавил отображение спеков не просто числами, а через круглый ProgressBar, где maxValue равно максимальному значению среди всех покемонов, таким образом, пользователь по заполненности шкалы может понять, насколько параметр отстает от максимально возможного.

Offline Mode:
Реализовано кэширование через Room Database. По мере загрузки данных с api они асинхронно в io потоке сохраняются в базу данных. Методы для работы с базы данных (из dao) имеют ту же сигнатуру, что и методы для работы с api, даже лист покемонов можно получить по номеру страницы, но в отличии от api, здесь сразу придет лист покемонов с полной информацией, а не лист превью. Сделал через Room, а не через Shared Preferences чтобы продемонстрировать скиллы. **Таким образом, пункт 3 дополнительного задания считаю выполненным**.
